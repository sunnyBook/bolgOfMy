<hr>
<p>title: JavaScript之继承、this问题和对象枚举<br>date: 2017-05-04 12:20:07<br>tags: [JavaScript]</p>
<h2 id="categories-JavaScript"><a href="#categories-JavaScript" class="headerlink" title="categories: JavaScript"></a>categories: JavaScript</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p> <strong>1、原型链式的继承</strong></p>
<p>这种继承有一个缺点就是它会继承过多没有用的属性，造成大量浪费.</p>
<p><img src="http://img.blog.csdn.net/20170504115213631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3Vuc2hpbmVhbmw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>2、借用构造函数</strong></p>
<p><img src="http://img.blog.csdn.net/20170504115516523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3Vuc2hpbmVhbmw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但是这种方式有两个缺点：</p>
<ol>
<li>严格说，这种方式不属于继承，也访问不了原型的原型</li>
<li>每次构造一个对象都要走两个构造函数，效率很低</li>
</ol>
<p><strong>3、共享原型</strong></p>
<pre><code>Son.prototype = Foo.prototype;
</code></pre><p>但是这种方法也有弊端，那就是如果向单独改变子类原型上的属性时，就会两个一起都改变了。</p>
<p><strong>4、圣杯模式</strong></p>
<pre><code>var inherit = (function () {
    var f = function () {};
    return function (C, P) {
        F.prototype = P.prototype;
        C.prototype = new F();
        C.prototype.constructor = C;
        C.prototype.uber = P;
    }
} ());
</code></pre><h2 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h2><p>1、预编译过程中 this -&gt; window</p>
<p>2、全局作用域里面 this -&gt; window</p>
<p>3、call/apply可以改变this指向</p>
<p>4、obj.func() 里面的this指向obj（谁调用的指向谁）</p>
<p>下面看一下例题：</p>
<pre><code>var name = &apos;222&apos;;
var a = {
    name : &apos;111&apos;,
    say : function () {
        console.log(this.name);
    }
}

var fun = a.say;
fun();            // 输出222
a.say();          // 输出111
var b = {
    name : &apos;333&apos;,
    say : function (fun) {
        func();
    }
}

b.say (a.say);    //输出222
b.say = a.say;
b.say();          //输出333
</code></pre><p><strong>call和apply：</strong></p>
<p>apply和call基本没有区别，都是改变this指向的作用，唯一的区别是call后面的参数是一个一个传的，而apply后面的参数是放进一个数组里面然后传进去的。</p>
<h2 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h2><p><strong>1、obj[‘name’]</strong></p>
<p>这种对象查看的方式和数组类似，我们常用的obj.name在底层也会默认转成这种形式的，所以我推荐尽量采用这种方式查看对象的属性。</p>
<p><strong>2、for-in</strong></p>
<p>for-in循环会按照属性的顺序取出属性名然后赋给prop，obj[prop]则是相应的属性的值。</p>
<p><strong>注意：</strong>如果写成obj.prop的形式，因为在系统底层会转成obj[‘prop’]的形式，但是我们并没有prop这个属性，所以会打印出来undefined。</p>
<p><strong>3、hasOwnProperty</strong></p>
<p>值得注意的是，在ES3和ES5的非严格模式中，for-in循环会把原型上的属性一起打印出来，所以就需要我们用hasOwnProperty来进行判断。</p>
<pre><code>function Person () {
    this.name : &apos;zhagsan&apos;;
}
Person.prototype = {
    sex : &apos;male&apos;
}
var oP = new Person();
for (var prop in oP) {
    if (oP.hasOwnProperty(prop)) {
        console.log(oP[prop]);
    }
}
</code></pre><p>这样打印出来的数据就都是对象自身的属性了。</p>
<p><strong>4、instanceof操作符</strong></p>
<p>作用：判断前面对象的原型链上是否有后面构造对象</p>
<p>oP instanceof Person; // true<br>oP instanceof Object; // true<br>{} instanceof Object; // true<br>{} instanceof Person; // false</p>
